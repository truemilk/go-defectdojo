// Package defectdojo provides a Go client library for accessing the DefectDojo API v2.
// This file contains the Products service implementation for managing security products.
package defectdojo

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"
)

// ProductsService handles communication with the products related methods of the DefectDojo API.
// It provides methods to list, read, create, and delete products in DefectDojo.
type ProductsService struct {
	client *Client
}

// Product represents a product in DefectDojo, which is a logical grouping of security tests
// and findings for a specific application, system, or service.
type Product struct {
	// ID is the unique identifier for the product
	ID *int `json:"id,omitempty"`
	// FindingsCount is the total number of findings associated with this product
	FindingsCount *int `json:"findings_count,omitempty"`
	// FindingsList contains the IDs of findings associated with this product
	FindingsList *[]int `json:"findings_list,omitempty"`
	// Tags are user-defined labels for organizing and categorizing products
	Tags *[]string `json:"tags,omitempty"`
	// ProductMeta contains custom metadata key-value pairs for the product
	ProductMeta *[]struct {
		// Name is the metadata key
		Name *string `json:"name,omitempty"`
		// Value is the metadata value
		Value *string `json:"value,omitempty"`
	} `json:"product_meta,omitempty"`
	// Name is the human-readable name of the product
	Name *string `json:"name,omitempty"`
	// Description provides additional details about the product
	Description *string `json:"description,omitempty"`
	// Created is the timestamp when the product was created
	Created *time.Time `json:"created,omitempty"`
	// ProdNumericGrade is the numerical grade assigned to the product
	ProdNumericGrade *int `json:"prod_numeric_grade,omitempty"`
	// BusinessCriticality indicates the importance of the product to the business
	BusinessCriticality *string `json:"business_criticality,omitempty"`
	// Platform specifies the technology platform the product runs on
	Platform *string `json:"platform,omitempty"`
	// Lifecycle indicates the current stage of the product lifecycle
	Lifecycle *string `json:"lifecycle,omitempty"`
	// Origin describes where the product originated from
	Origin *string `json:"origin,omitempty"`
	// UserRecords is the number of user records the product handles
	UserRecords *int `json:"user_records,omitempty"`
	// Revenue is the revenue generated by the product
	Revenue *string `json:"revenue,omitempty"`
	// ExternalAudience indicates if the product is accessible to external users
	ExternalAudience *bool `json:"external_audience,omitempty"`
	// InternetAccessible indicates if the product is accessible from the internet
	InternetAccessible *bool `json:"internet_accessible,omitempty"`
	// EnableSimpleRiskAcceptance allows simple risk acceptance for findings
	EnableSimpleRiskAcceptance *bool `json:"enable_simple_risk_acceptance,omitempty"`
	// EnableFullRiskAcceptance allows full risk acceptance for findings
	EnableFullRiskAcceptance *bool `json:"enable_full_risk_acceptance,omitempty"`
	// ProductManager is the ID of the user who manages the product
	ProductManager *int `json:"product_manager,omitempty"`
	// TechnicalContact is the ID of the technical contact for the product
	TechnicalContact *int `json:"technical_contact,omitempty"`
	// TeamManager is the ID of the team manager for the product
	TeamManager *int `json:"team_manager,omitempty"`
	// ProdType is the ID of the product type this product belongs to
	ProdType *int `json:"prod_type,omitempty"`
	// Members contains the IDs of users who are members of this product
	Members *[]int `json:"members,omitempty"`
	// AuthorizationGroups contains the IDs of authorization groups for this product
	AuthorizationGroups *[]int `json:"authorization_groups,omitempty"`
	// Regulations contains the IDs of regulations that apply to this product
	Regulations *[]int `json:"regulations,omitempty"`
}

// Products represents a paginated response containing multiple products from the DefectDojo API.
type Products struct {
	// Count is the total number of products matching the query
	Count *int `json:"count,omitempty"`
	// Next is the URL for the next page of results
	Next *string `json:"next,omitempty"`
	// Previous is the URL for the previous page of results
	Previous *string `json:"previous,omitempty"`
	// Results contains the actual product data for the current page
	Results *[]Product `json:"results,omitempty"`
	// Prefetch contains related objects that were prefetched to reduce API calls
	Prefetch *struct {
		// AuthorizationGroups maps authorization group IDs to their full objects
		AuthorizationGroups *map[string]DojoGroup `json:"authorization_groups,omitempty"`
		// Members maps user IDs to their full user objects
		Members *map[string]User `json:"members,omitempty"`
		// ProdType maps product type IDs to their full product type objects
		ProdType *map[string]ProductType `json:"prod_type,omitempty"`
		// ProductManager maps user IDs to their full user objects for product managers
		ProductManager *map[string]User `json:"product_manager,omitempty"`
		// TeamManager maps user IDs to their full user objects for team managers
		TeamManager *map[string]User `json:"team_manager,omitempty"`
		// TechnicalContact maps user IDs to their full user objects for technical contacts
		TechnicalContact *map[string]User `json:"technical_contact,omitempty"`
	} `json:"prefetch,omitempty"`
}

// ProductsOptions contains optional parameters for filtering and paginating products.
type ProductsOptions struct {
	// Limit specifies the maximum number of products to return (default: 20)
	Limit int
	// Offset specifies the starting position for pagination
	Offset int
	// Name filters products by name (partial match)
	Name string
	// Prefetch specifies related objects to include in the response to reduce API calls
	Prefetch string
}

// ToString converts ProductsOptions to a URL query string for API requests.
// It returns an empty string if no options are set, otherwise returns a query string
// starting with '?' and containing the appropriate parameters.
func (o *ProductsOptions) ToString() string {
	var opts []string
	var optsString string
	if o != nil {
		optsString += "?"
		if o.Limit > 0 {
			opts = append(opts, fmt.Sprintf("limit=%d", o.Limit))
		}
		if o.Offset > 0 {
			opts = append(opts, fmt.Sprintf("offset=%d", o.Offset))
		}
		if len(o.Name) > 0 {
			opts = append(opts, fmt.Sprintf("name=%s", o.Name))
		}
		if len(o.Prefetch) > 0 {
			opts = append(opts, fmt.Sprintf("prefetch=%s", o.Prefetch))
		}
		optsString += strings.Join(opts, "&")
	}
	return optsString
}

// List retrieves a paginated list of products from DefectDojo.
// It accepts optional filtering and pagination parameters through ProductsOptions.
// The returned Products struct contains the results and pagination information.
func (c *ProductsService) List(ctx context.Context, options *ProductsOptions) (*Products, error) {
	path := fmt.Sprintf("%s/products/%s", c.client.BaseURL, options.ToString())

	req, err := http.NewRequest(http.MethodGet, path, nil)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)

	res := Products{}
	if err := c.client.sendRequest(req, &res); err != nil {
		return nil, err
	}

	return &res, nil
}

// Read retrieves a single product by its ID from DefectDojo.
// It returns the complete product information including all fields and relationships.
func (c *ProductsService) Read(ctx context.Context, id int) (*Product, error) {
	path := fmt.Sprintf("%s/products/%d/", c.client.BaseURL, id)

	req, err := http.NewRequest(http.MethodGet, path, nil)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)

	res := new(Product)
	if err := c.client.sendRequest(req, &res); err != nil {
		return nil, err
	}

	return res, nil
}

// Create creates a new product in DefectDojo.
// It accepts a Product struct with the desired fields set and returns the created product
// with server-generated fields like ID and timestamps populated.
func (c *ProductsService) Create(ctx context.Context, u *Product) (*Product, error) {
	path := fmt.Sprintf("%s/products/", c.client.BaseURL)

	postJSON, err := json.Marshal(u)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, path, bytes.NewBuffer(postJSON))
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)

	res := new(Product)
	if err := c.client.sendRequest(req, &res); err != nil {
		return nil, err
	}

	return res, nil
}

// Delete removes a product from DefectDojo by its ID.
// It returns the deleted product information. Note that deleting a product
// may also delete associated engagements, tests, and findings.
func (c *ProductsService) Delete(ctx context.Context, id int) (*Product, error) {
	path := fmt.Sprintf("%s/products/%d/", c.client.BaseURL, id)

	req, err := http.NewRequest(http.MethodDelete, path, nil)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)

	res := new(Product)
	if err := c.client.sendRequest(req, &res); err != nil {
		return nil, err
	}

	return res, nil
}
